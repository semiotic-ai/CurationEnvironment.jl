var documenterSearchIndex = {"docs":
[{"location":"experiments/community_signal/welfare_maximisation/#cs_wm","page":"Welfare Maximisation in the Community Signal Model","title":"Welfare Maximisation in the Community Signal Model","text":"","category":"section"},{"location":"experiments/community_signal/welfare_maximisation/","page":"Welfare Maximisation in the Community Signal Model","title":"Welfare Maximisation in the Community Signal Model","text":"(Image: Source code) (Image: compat) (Image: Author) (Image: Update time)","category":"page"},{"location":"experiments/community_signal/welfare_maximisation/","page":"Welfare Maximisation in the Community Signal Model","title":"Welfare Maximisation in the Community Signal Model","text":"Welfare maximisation is defined as in the Curation v2 yellowpaper. The main idea is that a welfare-maximising state is one in which curators that value subgraph most own the shares and the minimum viable signal is met for all curators Generally speaking, as we shall see, there exist equilibria for the Community Signal (CS) model of curation that are not welfare-maximising.","category":"page"},{"location":"experiments/community_signal/welfare_maximisation/","page":"Welfare Maximisation in the Community Signal Model","title":"Welfare Maximisation in the Community Signal Model","text":"Seed for reproducibility","category":"page"},{"location":"experiments/community_signal/welfare_maximisation/","page":"Welfare Maximisation in the Community Signal Model","title":"Welfare Maximisation in the Community Signal Model","text":"const seed = 343\nusing Random\nrng = MersenneTwister(seed)\n\nusing CurationEnvironment\nusing Accessors\nusing CSV\nusing DataFrames\nusing CairoMakie","category":"page"},{"location":"experiments/community_signal/welfare_maximisation/","page":"Welfare Maximisation in the Community Signal Model","title":"Welfare Maximisation in the Community Signal Model","text":"Here we define a few helper functions for this experiment","category":"page"},{"location":"experiments/community_signal/welfare_maximisation/","page":"Welfare Maximisation in the Community Signal Model","title":"Welfare Maximisation in the Community Signal Model","text":"rep(x, n) = repeat([x], n)\n\nfunction utility(cump, c, s)\n    ξ = ςs(c, id(s)) / ς(s)\n    v̂max = v̂maxs(c, id(s))\n    return ξ * v̂max - cump\nend\n\nfunction logc(m, d, i, c, nc, s)\n    texnames = [\"A\", \"B\", \"C\", \"D\", \"E\"]\n    name = texnames[i]\n    tx = σ(nc) != σ(c) ? 1.0 : 0.0\n    push!(d[\"curator$(name)trans\"], d[\"curator$(name)trans\"][end] + tx)\n    p = σ(c) - σ(nc)\n    push!(d[\"curator$(name)p\"], d[\"curator$(name)p\"][end] + p)\n    push!(d[\"curator$(name)fees\"], d[\"curator$(name)fees\"][end] + latefees(m, p, s))\n    push!(d[\"curator$(name)utility\"], utility(d[\"curator$(name)p\"][end], nc, s))\n    push!(d[\"curator$(name)shares\"], ςs(nc, id(s)))\n    return d\nend\n\nfunction logc(m, d, i, c)\n    texnames = [\"A\", \"B\", \"C\", \"D\", \"E\"]\n    name = texnames[i]\n    push!(d[\"curator$(name)trans\"], d[\"curator$(name)trans\"][end])\n    push!(d[\"curator$(name)utility\"], d[\"curator$(name)utility\"][end])\n    push!(d[\"curator$(name)fees\"], d[\"curator$(name)fees\"][end])\n    push!(d[\"curator$(name)p\"], d[\"curator$(name)p\"][end])\n    push!(d[\"curator$(name)shares\"], d[\"curator$(name)shares\"][end])\n    return d\nend","category":"page"},{"location":"experiments/community_signal/welfare_maximisation/","page":"Welfare Maximisation in the Community Signal Model","title":"Welfare Maximisation in the Community Signal Model","text":"Constants","category":"page"},{"location":"experiments/community_signal/welfare_maximisation/","page":"Welfare Maximisation in the Community Signal Model","title":"Welfare Maximisation in the Community Signal Model","text":"const feerate = 0.05\nconst t = τ(feerate)\nconst num_t = 50  # timesteps\nconst m = CommunitySignal()\nconst num_s = 1  # subgraphs\nconst num_c = 5  # curators\nconst π = best_response","category":"page"},{"location":"experiments/community_signal/welfare_maximisation/","page":"Welfare Maximisation in the Community Signal Model","title":"Welfare Maximisation in the Community Signal Model","text":"Create the curators and subgraph In this experiment, the curators have unlimited budget. We can make this assumption due to signal renting.","category":"page"},{"location":"experiments/community_signal/welfare_maximisation/","page":"Welfare Maximisation in the Community Signal Model","title":"Welfare Maximisation in the Community Signal Model","text":"const v̂lows = (1000.0, 500.0, 1500.0, 1750.0, 0.0)\nconst v̂highs = (2500.0, 4000.0, 2000.0, 3500.0, 3000.0)\nconst shares = (0.0, 0.0, 0.0, 0.0, 0.0)\nconst stakes = (10000.0, 10000.0, 10000.0, 10000.0, 10000.0)\ncs = map(1:num_c, v̂lows, v̂highs, shares, stakes)  do i, vl, vh, ς, σ\n        return MinMaxCurator{num_s,Int64,Float64}(i, (vl,), (vh,), (ς,), σ)\n    end\ns = Subgraph(1, 500.0, 500.0, t)","category":"page"},{"location":"experiments/community_signal/welfare_maximisation/","page":"Welfare Maximisation in the Community Signal Model","title":"Welfare Maximisation in the Community Signal Model","text":"We can look at the generated curators","category":"page"},{"location":"experiments/community_signal/welfare_maximisation/","page":"Welfare Maximisation in the Community Signal Model","title":"Welfare Maximisation in the Community Signal Model","text":"@show cs","category":"page"},{"location":"experiments/community_signal/welfare_maximisation/","page":"Welfare Maximisation in the Community Signal Model","title":"Welfare Maximisation in the Community Signal Model","text":"And the generated subgraph","category":"page"},{"location":"experiments/community_signal/welfare_maximisation/","page":"Welfare Maximisation in the Community Signal Model","title":"Welfare Maximisation in the Community Signal Model","text":"@show s","category":"page"},{"location":"experiments/community_signal/welfare_maximisation/","page":"Welfare Maximisation in the Community Signal Model","title":"Welfare Maximisation in the Community Signal Model","text":"If the mechanism is welfare-maximising, we expect that curator B (2), will be the only curator to end up with shares. It has sufficient budget to own all of the shares. Thus, since it values the subgraphs the most, it should pay enough to get all of the shares.","category":"page"},{"location":"experiments/community_signal/welfare_maximisation/","page":"Welfare Maximisation in the Community Signal Model","title":"Welfare Maximisation in the Community Signal Model","text":"Create a dictionary for logging.","category":"page"},{"location":"experiments/community_signal/welfare_maximisation/","page":"Welfare Maximisation in the Community Signal Model","title":"Welfare Maximisation in the Community Signal Model","text":"info = Dict(\n    \"time\" => map(i -> i, 1:(num_t + 1)),\n    \"shares\" => [ς(s)],\n    \"price\" => [v(s) / ς(s)],\n    \"feeRate\" => rep(feerate, num_t + 1),\n    \"curatorAtrans\" => [0.0],\n    \"curatorAmax\" => rep(v̂maxs(cs[1], 1), num_t + 1),\n    \"curatorAmin\" => rep(v̂mins(cs[1], 1), num_t + 1),\n    \"curatorAfees\" => [0.0],\n    \"curatorAutility\" => [0.0],\n    \"curatorAp\" => [0.0],  # running sum of payments\n    \"curatorAshares\" => [0.0],\n    \"curatorBtrans\" => [0.0],\n    \"curatorBmax\" => rep(v̂maxs(cs[2], 1), num_t + 1),\n    \"curatorBmin\" => rep(v̂mins(cs[2], 1), num_t + 1),\n    \"curatorBfees\" => [0.0],\n    \"curatorButility\" => [0.0],\n    \"curatorBp\" => [0.0],\n    \"curatorBshares\" => [0.0],\n    \"curatorCtrans\" => [0.0],\n    \"curatorCmax\" => rep(v̂maxs(cs[3], 1), num_t + 1),\n    \"curatorCmin\" => rep(v̂mins(cs[3], 1), num_t + 1),\n    \"curatorCfees\" => [0.0],\n    \"curatorCutility\" => [0.0],\n    \"curatorCp\" => [0.0],\n    \"curatorCshares\" => [0.0],\n    \"curatorDtrans\" => [0.0],\n    \"curatorDmax\" => rep(v̂maxs(cs[4], 1), num_t + 1),\n    \"curatorDmin\" => rep(v̂mins(cs[4], 1), num_t + 1),\n    \"curatorDfees\" => [0.0],\n    \"curatorDutility\" => [0.0],\n    \"curatorDp\" => [0.0],\n    \"curatorDshares\" => [0.0],\n    \"curatorEtrans\" => [0.0],\n    \"curatorEmax\" => rep(v̂maxs(cs[5], 1), num_t + 1),\n    \"curatorEmin\" => rep(v̂mins(cs[5], 1), num_t + 1),\n    \"curatorEfees\" => [0.0],\n    \"curatorEutility\" => [0.0],\n    \"curatorEp\" => [0.0],\n    \"curatorEshares\" => [0.0],\n    \"signal\" => [v(s)],\n)","category":"page"},{"location":"experiments/community_signal/welfare_maximisation/","page":"Welfare Maximisation in the Community Signal Model","title":"Welfare Maximisation in the Community Signal Model","text":"Now we run the following experiment. At each timestep, curators play a greedy strategy to try to maximise their utility. We see at the end of this if the curator who values the subgraph the most owns all the new shares on the subgraph. Note that since we start with 500 shares on the subgraph, they won't own all the shares on the subgraph. Since the curators all have unlimited budgets, if the mechanism is welfare-maximising, we shouldn't have multiple curators curating the subgraph at the end of the this process.","category":"page"},{"location":"experiments/community_signal/welfare_maximisation/","page":"Welfare Maximisation in the Community Signal Model","title":"Welfare Maximisation in the Community Signal Model","text":"is = collect(1:num_c)\nfor _ in 1:num_t\n    i = rand(rng, is)\n    c = cs[i]\n    nc, ns = CurationEnvironment.step(m, π, c, s)\n    global info = logc(m, info, i, c, nc, ns)\n    js = filter(j -> j != i, is)\n    for j in js\n        global info = logc(m, info, j, cs[j])\n    end\n    push!(info[\"shares\"], ς(ns))\n    push!(info[\"price\"], v(ns) / ς(ns))\n    push!(info[\"signal\"], v(ns))\n    global cs = @set cs[i] = nc\n    global s = ns\nend\n@show v(s)","category":"page"},{"location":"experiments/community_signal/welfare_maximisation/","page":"Welfare Maximisation in the Community Signal Model","title":"Welfare Maximisation in the Community Signal Model","text":"Convert to a dataframe to view data","category":"page"},{"location":"experiments/community_signal/welfare_maximisation/","page":"Welfare Maximisation in the Community Signal Model","title":"Welfare Maximisation in the Community Signal Model","text":"df = DataFrame(info)\nCSV.write(\"assets/welfare_max.csv\", df)\n@show df","category":"page"},{"location":"experiments/community_signal/welfare_maximisation/","page":"Welfare Maximisation in the Community Signal Model","title":"Welfare Maximisation in the Community Signal Model","text":"You can download/inspect the generated CSV if you'd like. In any case, we can see that the mechanism is not welfare-maximising in this case. Curator B (2) did not end up with all of the new shares on the subgraph.","category":"page"},{"location":"experiments/community_signal/welfare_maximisation/","page":"Welfare Maximisation in the Community Signal Model","title":"Welfare Maximisation in the Community Signal Model","text":"time = info[\"time\"]\nf = Figure()\nax = Axis(f[1, 1]; title=\"Welfare Max CS\", xlabel=\"time\", ylabel=\"shares\")\nlines!(ax, time, info[\"curatorAshares\"]; label = \"A\")\nlines!(ax, time, info[\"curatorBshares\"]; label = \"B\")\nlines!(ax, time, info[\"curatorCshares\"]; label = \"C\")\nlines!(ax, time, info[\"curatorDshares\"]; label = \"D\")\nlines!(ax, time, info[\"curatorEshares\"]; label = \"E\")\naxislegend(ax)\nsave(\"assets/welfare_max.png\", f)\nf","category":"page"},{"location":"experiments/community_signal/welfare_maximisation/","page":"Welfare Maximisation in the Community Signal Model","title":"Welfare Maximisation in the Community Signal Model","text":"","category":"page"},{"location":"experiments/community_signal/welfare_maximisation/","page":"Welfare Maximisation in the Community Signal Model","title":"Welfare Maximisation in the Community Signal Model","text":"This page was generated using DemoCards.jl and Literate.jl.","category":"page"},{"location":"experiments/community_signal_auction/welfare_maximisation/#csa_wm","page":"Welfare Maximisation in the Community Signal Auction Model","title":"Welfare Maximisation in the Community Signal Auction Model","text":"","category":"section"},{"location":"experiments/community_signal_auction/welfare_maximisation/","page":"Welfare Maximisation in the Community Signal Auction Model","title":"Welfare Maximisation in the Community Signal Auction Model","text":"(Image: Source code) (Image: compat) (Image: Author) (Image: Update time)","category":"page"},{"location":"experiments/community_signal_auction/welfare_maximisation/","page":"Welfare Maximisation in the Community Signal Auction Model","title":"Welfare Maximisation in the Community Signal Auction Model","text":"Welfare maximisation is defined as in the Curation v2 yellowpaper. The main idea is that a welfare-maximising state is one in which curators that value subgraph most own the shares and the minimum viable signal is met for all curators Generally speaking, as we shall see, the community signal auction is welfare-maximising.","category":"page"},{"location":"experiments/community_signal_auction/welfare_maximisation/","page":"Welfare Maximisation in the Community Signal Auction Model","title":"Welfare Maximisation in the Community Signal Auction Model","text":"using CurationEnvironment\nusing Accessors\nusing CSV\nusing DataFrames\nusing CairoMakie","category":"page"},{"location":"experiments/community_signal_auction/welfare_maximisation/","page":"Welfare Maximisation in the Community Signal Auction Model","title":"Welfare Maximisation in the Community Signal Auction Model","text":"Here we define a few helper functions for this experiment","category":"page"},{"location":"experiments/community_signal_auction/welfare_maximisation/","page":"Welfare Maximisation in the Community Signal Auction Model","title":"Welfare Maximisation in the Community Signal Auction Model","text":"rep(x, n) = repeat([x], n)\n\nfunction utility(cump, c, s)\n    ξ = ςs(c, id(s)) / ς(s)\n    v̂max = v̂maxs(c, id(s))\n    return ξ * v̂max - cump\nend\n\nfunction logc(m, d, i, c, nc, s)\n    texnames = [\"A\", \"B\", \"C\", \"D\", \"E\"]\n    name = texnames[i]\n    tx = σ(nc) != σ(c) ? 1.0 : 0.0\n    push!(d[\"curator$(name)trans\"], d[\"curator$(name)trans\"][end] + tx)\n    p = σ(c) - σ(nc)\n    push!(d[\"curator$(name)p\"], d[\"curator$(name)p\"][end] + p)\n    push!(d[\"curator$(name)fees\"], d[\"curator$(name)fees\"][end] + latefees(m, p, s))\n    push!(d[\"curator$(name)utility\"], utility(d[\"curator$(name)p\"][end], nc, s))\n    push!(d[\"curator$(name)shares\"], ςs(nc, id(s)))\n    return d\nend","category":"page"},{"location":"experiments/community_signal_auction/welfare_maximisation/","page":"Welfare Maximisation in the Community Signal Auction Model","title":"Welfare Maximisation in the Community Signal Auction Model","text":"Constants","category":"page"},{"location":"experiments/community_signal_auction/welfare_maximisation/","page":"Welfare Maximisation in the Community Signal Auction Model","title":"Welfare Maximisation in the Community Signal Auction Model","text":"const feerate = 0.05\nconst t = τ(feerate)\nconst num_t = 50  # timesteps\nconst m = CRSPE(CommunitySignal())\nconst num_s = 1  # subgraphs\nconst num_c = 5  # curators\nconst πs = map(_ -> best_response, 1:num_c)","category":"page"},{"location":"experiments/community_signal_auction/welfare_maximisation/","page":"Welfare Maximisation in the Community Signal Auction Model","title":"Welfare Maximisation in the Community Signal Auction Model","text":"Create the curators and subgraph In this experiment, the curators have unlimited budget. We can make this assumption due to signal renting.","category":"page"},{"location":"experiments/community_signal_auction/welfare_maximisation/","page":"Welfare Maximisation in the Community Signal Auction Model","title":"Welfare Maximisation in the Community Signal Auction Model","text":"const v̂lows = (1000.0, 500.0, 1500.0, 1750.0, 0.0)\nconst v̂highs = (2500.0, 4000.0, 2000.0, 3500.0, 3000.0)\nconst shares = (0.0, 0.0, 0.0, 0.0, 0.0)\nconst stakes = (10000.0, 10000.0, 10000.0, 10000.0, 10000.0)\ncs = map(1:num_c, v̂lows, v̂highs, shares, stakes)  do i, vl, vh, ς, σ\n        return MinMaxCurator{num_s,Int64,Float64}(i, (vl,), (vh,), (ς,), σ)\n    end\ns = Subgraph(1, 500.0, 500.0, t)","category":"page"},{"location":"experiments/community_signal_auction/welfare_maximisation/","page":"Welfare Maximisation in the Community Signal Auction Model","title":"Welfare Maximisation in the Community Signal Auction Model","text":"We can look at the generated curators","category":"page"},{"location":"experiments/community_signal_auction/welfare_maximisation/","page":"Welfare Maximisation in the Community Signal Auction Model","title":"Welfare Maximisation in the Community Signal Auction Model","text":"@show cs","category":"page"},{"location":"experiments/community_signal_auction/welfare_maximisation/","page":"Welfare Maximisation in the Community Signal Auction Model","title":"Welfare Maximisation in the Community Signal Auction Model","text":"And the generated subgraph","category":"page"},{"location":"experiments/community_signal_auction/welfare_maximisation/","page":"Welfare Maximisation in the Community Signal Auction Model","title":"Welfare Maximisation in the Community Signal Auction Model","text":"@show s","category":"page"},{"location":"experiments/community_signal_auction/welfare_maximisation/","page":"Welfare Maximisation in the Community Signal Auction Model","title":"Welfare Maximisation in the Community Signal Auction Model","text":"If the mechanism is welfare-maximising, we expect that curator B (2), will be the only curator to end up with shares. It has sufficient budget to own all of the shares. Thus, since it values the subgraphs the most, it should pay enough to get all of the shares.","category":"page"},{"location":"experiments/community_signal_auction/welfare_maximisation/","page":"Welfare Maximisation in the Community Signal Auction Model","title":"Welfare Maximisation in the Community Signal Auction Model","text":"Create a dictionary for logging.","category":"page"},{"location":"experiments/community_signal_auction/welfare_maximisation/","page":"Welfare Maximisation in the Community Signal Auction Model","title":"Welfare Maximisation in the Community Signal Auction Model","text":"info = Dict(\n    \"time\" => map(i -> i, 1:(num_t + 1)),\n    \"shares\" => [ς(s)],\n    \"price\" => [v(s) / ς(s)],\n    \"feeRate\" => rep(feerate, num_t + 1),\n    \"curatorAtrans\" => [0.0],\n    \"curatorAmax\" => rep(v̂maxs(cs[1], 1), num_t + 1),\n    \"curatorAmin\" => rep(v̂mins(cs[1], 1), num_t + 1),\n    \"curatorAfees\" => [0.0],\n    \"curatorAutility\" => [0.0],\n    \"curatorAp\" => [0.0],  # running sum of payments\n    \"curatorAshares\" => [0.0],\n    \"curatorBtrans\" => [0.0],\n    \"curatorBmax\" => rep(v̂maxs(cs[2], 1), num_t + 1),\n    \"curatorBmin\" => rep(v̂mins(cs[2], 1), num_t + 1),\n    \"curatorBfees\" => [0.0],\n    \"curatorButility\" => [0.0],\n    \"curatorBp\" => [0.0],\n    \"curatorBshares\" => [0.0],\n    \"curatorCtrans\" => [0.0],\n    \"curatorCmax\" => rep(v̂maxs(cs[3], 1), num_t + 1),\n    \"curatorCmin\" => rep(v̂mins(cs[3], 1), num_t + 1),\n    \"curatorCfees\" => [0.0],\n    \"curatorCutility\" => [0.0],\n    \"curatorCp\" => [0.0],\n    \"curatorCshares\" => [0.0],\n    \"curatorDtrans\" => [0.0],\n    \"curatorDmax\" => rep(v̂maxs(cs[4], 1), num_t + 1),\n    \"curatorDmin\" => rep(v̂mins(cs[4], 1), num_t + 1),\n    \"curatorDfees\" => [0.0],\n    \"curatorDutility\" => [0.0],\n    \"curatorDp\" => [0.0],\n    \"curatorDshares\" => [0.0],\n    \"curatorEtrans\" => [0.0],\n    \"curatorEmax\" => rep(v̂maxs(cs[5], 1), num_t + 1),\n    \"curatorEmin\" => rep(v̂mins(cs[5], 1), num_t + 1),\n    \"curatorEfees\" => [0.0],\n    \"curatorEutility\" => [0.0],\n    \"curatorEp\" => [0.0],\n    \"curatorEshares\" => [0.0],\n    \"signal\" => [v(s)],\n)","category":"page"},{"location":"experiments/community_signal_auction/welfare_maximisation/","page":"Welfare Maximisation in the Community Signal Auction Model","title":"Welfare Maximisation in the Community Signal Auction Model","text":"Now we run the following experiment. At each timestep, curators play a greedy strategy to try to maximise their utility. We see at the end of this if the curator who values the subgraph the most owns all the new shares on the subgraph. Note that since we start with 500 shares on the subgraph, they won't own all the shares on the subgraph. Since the curators all have unlimited budgets, if the mechanism is welfare-maximising, we shouldn't have multiple curators curating the subgraph at the end of the this process.","category":"page"},{"location":"experiments/community_signal_auction/welfare_maximisation/","page":"Welfare Maximisation in the Community Signal Auction Model","title":"Welfare Maximisation in the Community Signal Auction Model","text":"is = collect(1:num_c)\nfor _ in 1:num_t\n    ncs, ns = CurationEnvironment.step(m, πs, cs, s)\n    for j in 1:num_c\n        global info = logc(m, info, j, cs[j], ncs[j], ns)\n    end\n    push!(info[\"shares\"], ς(ns))\n    push!(info[\"price\"], v(ns) / ς(ns))\n    push!(info[\"signal\"], v(ns))\n    global cs = ncs\n    global s = ns\nend\n@show v(s)","category":"page"},{"location":"experiments/community_signal_auction/welfare_maximisation/","page":"Welfare Maximisation in the Community Signal Auction Model","title":"Welfare Maximisation in the Community Signal Auction Model","text":"Convert to a dataframe to view data","category":"page"},{"location":"experiments/community_signal_auction/welfare_maximisation/","page":"Welfare Maximisation in the Community Signal Auction Model","title":"Welfare Maximisation in the Community Signal Auction Model","text":"df = DataFrame(info)\nCSV.write(\"assets/welfare_max.csv\", df)\n@show df","category":"page"},{"location":"experiments/community_signal_auction/welfare_maximisation/","page":"Welfare Maximisation in the Community Signal Auction Model","title":"Welfare Maximisation in the Community Signal Auction Model","text":"You can download/inspect the generated CSV if you'd like. In any case, we can see that the mechanism is welfare-maximising in this case. Curator B (2) did ended up with all of the new shares on the subgraph.","category":"page"},{"location":"experiments/community_signal_auction/welfare_maximisation/","page":"Welfare Maximisation in the Community Signal Auction Model","title":"Welfare Maximisation in the Community Signal Auction Model","text":"time = info[\"time\"]\nf = Figure()\nax = Axis(f[1, 1]; title=\"Welfare Max CS\", xlabel=\"time\", ylabel=\"shares\")\nlines!(ax, time, info[\"curatorAshares\"]; label = \"A\")\nlines!(ax, time, info[\"curatorBshares\"]; label = \"B\")\nlines!(ax, time, info[\"curatorCshares\"]; label = \"C\")\nlines!(ax, time, info[\"curatorDshares\"]; label = \"D\")\nlines!(ax, time, info[\"curatorEshares\"]; label = \"E\")\naxislegend(ax)\nsave(\"assets/welfare_max.png\", f)\nf","category":"page"},{"location":"experiments/community_signal_auction/welfare_maximisation/","page":"Welfare Maximisation in the Community Signal Auction Model","title":"Welfare Maximisation in the Community Signal Auction Model","text":"","category":"page"},{"location":"experiments/community_signal_auction/welfare_maximisation/","page":"Welfare Maximisation in the Community Signal Auction Model","title":"Welfare Maximisation in the Community Signal Auction Model","text":"This page was generated using DemoCards.jl and Literate.jl.","category":"page"},{"location":"experiments/#experiments","page":"Experiments","title":"Experiments","text":"","category":"section"},{"location":"experiments/","page":"Experiments","title":"Experiments","text":"This section documents experiments we have conducted to analyse various curation mechanisms for The Graph. For a full reference of The Graph's analysis of curation, please visit our Notion Page.","category":"page"},{"location":"experiments/","page":"Experiments","title":"Experiments","text":"","category":"page"},{"location":"experiments/#Community-signal","page":"Experiments","title":"Community signal","text":"","category":"section"},{"location":"experiments/","page":"Experiments","title":"Experiments","text":"<div class=\"list-card-section\">","category":"page"},{"location":"experiments/","page":"Experiments","title":"Experiments","text":"<div class=\"list-card\">\n<table>\n  <td valign=\"bottom\"><div class=\"list-card-cover\">","category":"page"},{"location":"experiments/","page":"Experiments","title":"Experiments","text":"(Image: list-card-cover-image)","category":"page"},{"location":"experiments/","page":"Experiments","title":"Experiments","text":"  </div></td>\n  <td><div class=\"list-card-text\">","category":"page"},{"location":"experiments/","page":"Experiments","title":"Experiments","text":"Welfare Maximisation in the Community Signal Model","category":"page"},{"location":"experiments/","page":"Experiments","title":"Experiments","text":"</div>\n    <div class=\"list-card-description\">","category":"page"},{"location":"experiments/","page":"Experiments","title":"Experiments","text":"This experiment investigates whether the Community Signal model is welfare-maximising. TL;DR - Failed.","category":"page"},{"location":"experiments/","page":"Experiments","title":"Experiments","text":"    </div>\n  </td>\n</tbody></table>\n</div>","category":"page"},{"location":"experiments/","page":"Experiments","title":"Experiments","text":"</div>","category":"page"},{"location":"experiments/#Community-signal-auction","page":"Experiments","title":"Community signal auction","text":"","category":"section"},{"location":"experiments/","page":"Experiments","title":"Experiments","text":"<div class=\"list-card-section\">","category":"page"},{"location":"experiments/","page":"Experiments","title":"Experiments","text":"<div class=\"list-card\">\n<table>\n  <td valign=\"bottom\"><div class=\"list-card-cover\">","category":"page"},{"location":"experiments/","page":"Experiments","title":"Experiments","text":"(Image: list-card-cover-image)","category":"page"},{"location":"experiments/","page":"Experiments","title":"Experiments","text":"  </div></td>\n  <td><div class=\"list-card-text\">","category":"page"},{"location":"experiments/","page":"Experiments","title":"Experiments","text":"Welfare Maximisation in the Community Signal Auction Model","category":"page"},{"location":"experiments/","page":"Experiments","title":"Experiments","text":"</div>\n    <div class=\"list-card-description\">","category":"page"},{"location":"experiments/","page":"Experiments","title":"Experiments","text":"This experiment investigates whether the Community Signal Auction model is welfare-maximising. TL;DR - Passed.","category":"page"},{"location":"experiments/","page":"Experiments","title":"Experiments","text":"    </div>\n  </td>\n</tbody></table>\n</div>","category":"page"},{"location":"experiments/","page":"Experiments","title":"Experiments","text":"</div>","category":"page"},{"location":"experiments/","page":"Experiments","title":"Experiments","text":"","category":"page"},{"location":"experiments/#Bugs","page":"Experiments","title":"Bugs","text":"","category":"section"},{"location":"experiments/","page":"Experiments","title":"Experiments","text":"If you find a bug in an experiment, please let us know by submitting a bug report.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = CurationEnvironment","category":"page"},{"location":"#CurationEnvironment","page":"Home","title":"CurationEnvironment","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for CurationEnvironment.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [CurationEnvironment]","category":"page"},{"location":"#CurationEnvironment.AbstractCurator","page":"Home","title":"CurationEnvironment.AbstractCurator","text":"AbstractCurator is the abstract type for all curators.\n\nAll properties of an AbstractCurator will have an associated getter and setter. For example, the Curator concretion has methods: id, v̂s, ςs, and σ. If you pass in only the AbstractCurator, or for some fields, the AbstractCurator and an index i, then the method serves as a getter. If you pass in a value v in addition to the parameters of the getters, the method serves as a setter.\n\nSee also Curator\n\n\n\n\n\n","category":"type"},{"location":"#CurationEnvironment.Auction","page":"Home","title":"CurationEnvironment.Auction","text":"Wrap a CurationModel in an auction.\n\n\n\n\n\n","category":"type"},{"location":"#CurationEnvironment.Bid","page":"Home","title":"CurationEnvironment.Bid","text":"The bid in an Auction.\n\n\n\n\n\n","category":"type"},{"location":"#CurationEnvironment.CRSPE","page":"Home","title":"CurationEnvironment.CRSPE","text":"CRSPE <: Auction\n\nA commit-reveal, second price auction has three stages:\n\nBid: Each participant privately bids (perhaps multiple times) via hash\n\ncommitment(s).\n\nReveal: Bidders (optionally) deposit tokens equal to their bid with a\n\nhash verification.\n\nAllocate: The highest bidder is reimbursed the difference between their\n\nbid and the second highest bid and allocated shares in proportion to their payment. All others are reimbursed for their deposits.\n\nConstructors\n\nCRSPE{M<:Model}(m::M)\nCRSPE(m::M)\n\n\n\n\n\n","category":"type"},{"location":"#CurationEnvironment.CommunitySignal","page":"Home","title":"CurationEnvironment.CommunitySignal","text":"CommunitySignal <: CurationModel\n\nReflect idea of of individuals contributing to a community asset.\n\nUnder this model, curators contribute tokens to the subgraph signal, which entitles them to shares. The shares entitle curators to rewards. Shares are created (minted) whenever a curator pays into the subgraph. Shares are destroyed (burned) whenever a curator withdraws funds from the subgraph.\n\nPart of curation involves encouraging people to curate early, rather than to curate just before query fees come in. In the community signal model, we encourage early curation via a late fee, a small percentage which decreases the effectiveness of your current payment based on the amount already on the subgraph. The late fee amount is distributed to all curators who had entered before you, thus rewarding them for being early.\n\n\n\n\n\n","category":"type"},{"location":"#CurationEnvironment.CurationModel","page":"Home","title":"CurationEnvironment.CurationModel","text":"Dynamics governing the interaction between a Subgraph and a Curator.\n\n\n\n\n\n","category":"type"},{"location":"#CurationEnvironment.Curator","page":"Home","title":"CurationEnvironment.Curator","text":"Curator{M,S,T} <: AbstractCurator\n\nSignal tokens on a Subgraph as per a private valuation.\n\nCurator is an entity that signals tokens on a Subgraph to demonstrate the value of the subgraph to indexers. Curators are paid via query fees when on a subgraph. Curator id estimates the subgraph valuations as v̂s and owns ςs shares on each subgraph. The curator has σ stake to spend.\n\nConstructors\n\nCurator{M,S,T}(\n    id::<:Integer,\n    vs::NTuple{M,T},\n    ςs::NTuple{M,T},\n    σ::T\n) where {S<:Integer, T<:Real}\n\nCurator{M}(id::<:Integer, ̂vs::NTuple{M,<:Real}, ςs::NTuple{M,<:Real}, σ::<:Real)\nCurator(id::<:Integer, ̂vs::NTuple{M,<:Real}, ςs::NTuple{M,<:Real}, σ::<:Real)\nCurator{M}(id::<:Integer, ̂v::<:Real, ς::<:Real, σ::<:Real)\n\n\n\n\n\n","category":"type"},{"location":"#CurationEnvironment.DoubleCRSPE","page":"Home","title":"CurationEnvironment.DoubleCRSPE","text":"DoubleCRSPE(m::CRSPE)\n\nThe difference between DoubleCRSPE and CRSPE is that in DoubleCRSPE, we burn tokens as per a CRSPE auction as well.\n\nThis can be constructed by bypassing CRSPE and directly specifying the CurationModel. DoubleCRSPE(CommunitySignal()).\n\n\n\n\n\n","category":"type"},{"location":"#CurationEnvironment.GraphEntity","page":"Home","title":"CurationEnvironment.GraphEntity","text":"A type of entity that interacts with The Graph protocol.\n\n\n\n\n\n","category":"type"},{"location":"#CurationEnvironment.MinMaxCurator","page":"Home","title":"CurationEnvironment.MinMaxCurator","text":"MinMaxCurator{M,S,T} <: AbstractCurator\n\nA curator that has both a min and max valuation.\n\nMinMaxCurator is a Curator that has both a minimum valuation for each subgraph v̂mins and a maximum valuation per subgraph v̂maxs. Intuitively, v̂min for a subgraph is the minimum amount of signal you would want to see on a subgraph. v̂max is your true valuation of the subgraph. The other parameters are as given by Curator.\n\nConstructors\n\nMinMaxCurator(\n    id::<:Integer,\n    v̂mins::NTuple{M,<:Real},\n    v̂maxs::NTuple{M,<:Real},\n    ςs::NTuple{M,<:Real},\n    σ::<:Real\n) where {M}\n\nMinMaxCurator{M,S,T}(\n    id::S,\n    v̂mins::NTuple{M,T},\n    v̂maxs::NTuple{M,T},\n    ςs::NTuple{M,T},\n    σ::T\n) where {M,S<:Integer,T<:Real}\n\n\n\n\n\n","category":"type"},{"location":"#CurationEnvironment.Subgraph","page":"Home","title":"CurationEnvironment.Subgraph","text":"Subgraph <: GraphEntity\n\nBlockchain data is organised into subgraphs.\n\nSubgraph is an entity on which curators signal tokens. Subgraph id has signal v, shares ς and late fee parameter of τ. τ is related to the late fee rate by τ.\n\nConstructors\n\nSubgraph{S,T}(id::S, v::T, ς::T, τ::T) where {S<:Integer,T<:Real}\nSubgraph(id::<:Integer, v::<:Real, ς::<:Real, τ::<:Real)\n\nSee also Curator\n\n\n\n\n\n","category":"type"},{"location":"#CurationEnvironment.auction-Union{Tuple{C}, Tuple{B}, Tuple{CRSPE, StructArrays.StructArray{B}, Vector{C}, Subgraph, Transaction}} where {B<:CRSPEBid, C<:MinMaxCurator}","page":"Home","title":"CurationEnvironment.auction","text":"auction(m::CRSPE, bids::StructArray{<:CRSPEBid}, cs::Vector{<:MinMaxCurator}, s::Subgraph, t::Transaction)\n\nRuns a commit-reveal second-price auction to select which bid wins the right to curate on the subgraph. The curators cs make transactions t based on bids on the subgraph s.\n\n\n\n\n\n","category":"method"},{"location":"#CurationEnvironment.best_response-Tuple{CRSPE{CommunitySignal}, MinMaxCurator, Subgraph}","page":"Home","title":"CurationEnvironment.best_response","text":"best_response(m::CRSPE{CommunitySignal}, c::MinMaxCurator, s::Subgraph)\n\nFind the best response for the min-max curator c on subgraph s.\n\n\n\n\n\n","category":"method"},{"location":"#CurationEnvironment.best_response-Tuple{CommunitySignal, MinMaxCurator, Subgraph}","page":"Home","title":"CurationEnvironment.best_response","text":"best_response(m::CommunitySignal, c::MinMaxCurator, s::Subgraph)\n\nFind the best response for the min-max curator c on subgraph s.\n\n\n\n\n\n","category":"method"},{"location":"#CurationEnvironment.best_response-Tuple{CommunitySignal, Real, Real, Real, Real, Real, Real}","page":"Home","title":"CurationEnvironment.best_response","text":"best_response(m::CommunitySignal, v::Real, v̂min::Real,\n              v̂max::Real τ::Real, ξ::Real, σ::Real)\n\nFind the best response on the community signal model for a subgraph with signal v and tax rate τ given the min-max curator believes the true value of the subgraph to be in the range v̂min and v̂max. The curator has the ratio ξ of the total shares on the subgraph and available stake σ.\n\n\n\n\n\n","category":"method"},{"location":"#CurationEnvironment.burnshares-Union{Tuple{C}, Tuple{B}, Tuple{CRSPE, StructArrays.StructArray{B}, Vector{C}, Subgraph}} where {B<:CRSPEBid, C<:MinMaxCurator}","page":"Home","title":"CurationEnvironment.burnshares","text":"burnshares(m::CRSPE, ps::StructArray{<:CRSPEBid}, cs::Vector{<:MinMaxCurator}, s::Subgraph)\n\nCurators cs who have negative payment in ps will burn shares on the subgraph s.\n\n\n\n\n\n","category":"method"},{"location":"#CurationEnvironment.burntokens-Union{Tuple{C}, Tuple{T}, Tuple{DoubleCRSPE, Vector{T}, Vector{C}, Subgraph}} where {T<:Real, C<:Curator}","page":"Home","title":"CurationEnvironment.burntokens","text":"burntokens(m::DoubleCRSPE, ps::Vector{<:Real}, cs::Vector{<:Curator}, s::Subgraph)\n\nCurators cs who have negative payment in ps will burn tokens on the subgraph s. In a DoubleCRSPE auction, they will burn tokens in a CRSPE auction.\n\n\n\n\n\n","category":"method"},{"location":"#CurationEnvironment.curate-Tuple{Model, Real, CurationEnvironment.AbstractCurator, Subgraph}","page":"Home","title":"CurationEnvironment.curate","text":"curate(m::Model, p::Real, c::Curator, s::Subgraph)\n\nA curator c curates tokens p on subgraph s as per model m.\n\nSee also Subgraph, Curator, CurationModel\n\n\n\n\n\n","category":"method"},{"location":"#CurationEnvironment.equity_proportion-Tuple{CommunitySignal, Real, Real, Real}","page":"Home","title":"CurationEnvironment.equity_proportion","text":"equity_proportion(::CommunitySignal, p::Real, v::Real, τ::Real)\n\nThe proportion of equity on a subgraph with signal v the curator will receive by paying amount p with tax rate τ.\n\n\n\n\n\n","category":"method"},{"location":"#CurationEnvironment.equity_proportion-Tuple{CommunitySignal, Real, Subgraph}","page":"Home","title":"CurationEnvironment.equity_proportion","text":"equity_proportion(model::CommunitySignal, p::Real, s::Subgraph)\n\nThe proportion of equity on a subgraph s the curator will receive by paying amount p.\n\n\n\n\n\n","category":"method"},{"location":"#CurationEnvironment.latefees-Tuple{CommunitySignal, Real, Subgraph}","page":"Home","title":"CurationEnvironment.latefees","text":"latefees(m::CommunitySignal, p::Real, s::Subgraph)\n\nThe late fees a curator makes for paying p on subgraph s.\n\n\n\n\n\n","category":"method"},{"location":"#CurationEnvironment.mintshares-Union{Tuple{C}, Tuple{B}, Tuple{CRSPE, StructArrays.StructArray{B}, Vector{C}, Subgraph}} where {B<:CRSPEBid, C<:MinMaxCurator}","page":"Home","title":"CurationEnvironment.mintshares","text":"mintshares(m::CRSPE, ps::Vector{<:CRSPEBid}, cs::Vector{<:MinMaxCurator}, s::Subgraph)\n\nCurators cs who have positive payment in ps will mint shares on the subgraph s.\n\n\n\n\n\n","category":"method"},{"location":"#CurationEnvironment.payment-Tuple{CommunitySignal, Real, Real, Real}","page":"Home","title":"CurationEnvironment.payment","text":"payment(::CommunitySignal, x::Real, v::Real, τ::Real)\n\nThe payment needed to capture or burn x proportion of the equity for a subgraph with valuation v and tax rate τ.\n\n\n\n\n\n","category":"method"},{"location":"#CurationEnvironment.payment-Tuple{CommunitySignal, Real, Subgraph}","page":"Home","title":"CurationEnvironment.payment","text":"payment(model::CommunitySignal, x::Real, s::Subgraph)\n\nThe payment needed to capture x proportion of the equity for a subgraph s.\n\n\n\n\n\n","category":"method"},{"location":"#CurationEnvironment.pmax-Tuple{CommunitySignal, Real, Real, Real, Real, Real}","page":"Home","title":"CurationEnvironment.pmax","text":"pmax(::CommunitySignal, v::Real, v̂max::Real, τ::Real, ξ::Real, σ::Real)\n\nThe maximum profitable payment.\n\nThe subgraph has signal v and a fee rate τ. The curator has a max valuation of v̂max, stake σ and owns ξ proportion of shares on the subgraph.\n\n\n\n\n\n","category":"method"},{"location":"#CurationEnvironment.popt-Tuple{CommunitySignal, Real, Real, Real, Real, Real, Real}","page":"Home","title":"CurationEnvironment.popt","text":"popt(::CommunitySignal, v::Real, v̂min::Real, v̂max::Real, τ::Real, ξ::Real)\n\nThe optimal amount to curate under the community signal model.\n\nThe subgraph has current signal v and fee rate τ. The curator has a min valuation v̂min,  a max valuationv̂max, and stakeσ. The curator ownsξ` proportion of the shares on the subgraph.\n\nSee also utility, pmax.\n\n\n\n\n\n","category":"method"},{"location":"#CurationEnvironment.shares-Tuple{CommunitySignal, Real, Real, Real, Real}","page":"Home","title":"CurationEnvironment.shares","text":"shares(model::CommunitySignal, x::Real, s::Real, v::Real, τ::Real)\n\nHow many new shares were minted when a curator executes a new transaction for equity proportion x on a subgraph with shares ς, signal v and tax rate τ.\n\n\n\n\n\n","category":"method"},{"location":"#CurationEnvironment.shares-Tuple{CommunitySignal, Real, Subgraph}","page":"Home","title":"CurationEnvironment.shares","text":"shares(model::CommunitySignal, x::Real, s::Subgraph)\n\nHow many new shares were minted when a curator executes a new transaction for equity proportion x on a subgraph s.\n\n\n\n\n\n","category":"method"},{"location":"#CurationEnvironment.step-Union{Tuple{A}, Tuple{F}, Tuple{CommunitySignal, F, Tuple{Vararg{A}}, Subgraph}} where {F<:Function, A<:CurationEnvironment.AbstractCurator}","page":"Home","title":"CurationEnvironment.step","text":"step(m::CommunitySignal, π::Function, c::Tuple{AbstractCurator}, s::Subgraph)\n\nCurators cs decide how much to curate on subgraph s by running the policy π.\n\nNote that the order in which the curators execute is randomised each time step is called.\n\n\n\n\n\n","category":"method"},{"location":"#CurationEnvironment.step-Union{Tuple{C}, Tuple{F}, Tuple{CRSPE, Vector{F}, Vector{C}, Subgraph}} where {F<:Function, C<:CurationEnvironment.AbstractCurator}","page":"Home","title":"CurationEnvironment.step","text":"step(m::CRSPE, πs::Vector{<:Function}, cs::Vector{<:AbstractCurator}, s::Subgraph) → Tuple{Tuple{Curator}, Subgraph}\n\nThe curators cs bid in a CRSPE auction on subgraph s according to policies πs.\n\nNOTE: Here, since we use a step function rather than async exec, the policies are executed together. This may be a bad assumption as burning can happen between auctions, whereas minting can only happen at discrete intervals with auctions.\n\n\n\n\n\n","category":"method"},{"location":"#CurationEnvironment.step-Union{Tuple{C}, Tuple{F}, Tuple{DoubleCRSPE, Vector{F}, Vector{C}, Subgraph}} where {F<:Function, C<:Curator}","page":"Home","title":"CurationEnvironment.step","text":"step(m::DoubleCRSPE, πs::Vector{<:Function}, cs::Vector{<:Curator}, s::Subgraph) → Tuple{Tuple{Curator}, Subgraph}\n\nThe curators cs bid in a Double CRSPE auction on subgraph s according to policies πs.\n\nNOTE: Here, since we use a step function rather than async exec, the policies are executed together. This may be a bad assumption as burning can happen between auctions, whereas minting can only happen at discrete intervals with auctions.\n\n\n\n\n\n","category":"method"},{"location":"#CurationEnvironment.step-Union{Tuple{F}, Tuple{CommunitySignal, F, CurationEnvironment.AbstractCurator, Subgraph}} where F<:Function","page":"Home","title":"CurationEnvironment.step","text":"step(m::CommunitySignal, π::Function, c::AbstractCurator, s::Subgraph)\n\nCurator c decides how much to curate on subgraph s by running the policy π.\n\n\n\n\n\n","category":"method"},{"location":"#CurationEnvironment.utility-Tuple{CommunitySignal, Real, MinMaxCurator, Subgraph}","page":"Home","title":"CurationEnvironment.utility","text":"utility(m::CommunitySignal, p::Real, c::MinMaxCurator, s::Subgraph)\n\nUtility on for payment p on subgraph s for the min-max curator c for model m.\n\n\n\n\n\n","category":"method"},{"location":"#CurationEnvironment.utility-Tuple{CommunitySignal, Real, Real, Real, Real, Real, Real}","page":"Home","title":"CurationEnvironment.utility","text":"utility(m::CommunitySignal, p::Real, v̂min::Real, v̂max::Real, v::Real, τ::Real, ξ::Real)\n\nUtility on for payment p for the min-max curator c for model m for a subgraph with signal v and tax rate τ given the min-max curator believes the true value of the subgraph to be in the range v̂min and v̂max. The curator has the ratio ξ of the total shares on the subgraph and available stake σ.\n\n\n\n\n\n","category":"method"},{"location":"#CurationEnvironment.winner-Union{Tuple{C}, Tuple{B}, Tuple{CRSPE, StructArrays.StructArray{B}, Vector{C}, Subgraph, Transaction}} where {B<:CRSPEBid, C<:MinMaxCurator}","page":"Home","title":"CurationEnvironment.winner","text":"winner(m::CRSPE, bids::StructArray{<:CRSPEBid}, cs::Vector{<:MinMaxCurator}, s::Subgraph, t::Transaction)\n\nFind the winner of the auction. The bidder who is willing to pay the most pays the price of the second-highest bid. The bidders cs make transaction t based on bids on the subgraph s.\n\n\n\n\n\n","category":"method"}]
}
